extern crate rand;
extern crate serde;
extern crate serde_binary;
extern crate serde_wasm_bindgen;
extern crate wasm_bindgen;
extern crate web_sys;

use ltcode::{
    CatchResult::{Finished, Missing},
    Decoder, DropType, Droplet, Encoder, EncoderType,
};
use serde::{Deserialize, Serialize};
use serde_binary::{binary_stream::Endian, from_vec, to_vec};
use wasm_bindgen::prelude::*;

mod ltcode;
mod soliton;
// 使用Option包装Decoder
static mut DECODER: Option<Decoder> = None;

// This file is @generated by prost-build.
#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct FilePkg {
    pub name: String,
    pub mime_type: String,
    pub data: Vec<u8>,
}

impl FilePkg {
    pub fn new(filename: String, mime_type: String, data: Vec<u8>) -> Self {
        Self {
            name: filename,
            mime_type: mime_type,
            data: data,
        }
    }
}

#[derive(Clone, PartialEq, Serialize, Deserialize)]
pub struct DropletPkg {
    pub droptype: Vec<u8>,
    pub data: Vec<u8>,
    pub total: usize,
}

impl DropletPkg {
    pub fn from_droplet(droplet: Droplet) -> Self {
        Self {
            droptype: DropType::serialize(&droplet.droptype),
            data: droplet.data,
            total: droplet.total,
        }
    }
    pub fn to_droplet(pkg: DropletPkg) -> Droplet {
        let droptype: Option<DropType> = DropType::deserialize(pkg.droptype);
        Droplet {
            droptype: droptype.unwrap(),
            data: pkg.data.clone(),
            total: pkg.total,
        }
    }
}

// 启用 web_sys 的 console 特性
#[wasm_bindgen]
extern "C" {
    #[wasm_bindgen(js_namespace = console)]
    fn log(s: &str);
}

#[wasm_bindgen]
pub fn init_encode(blocksize: usize, data: Vec<u8>) -> *mut Encoder {
    log(&format!("init_encode {}", data.len()));
    Box::into_raw(Box::new(Encoder::new(data, blocksize, EncoderType::Random)))
}

#[wasm_bindgen]
pub fn init_encode_from_file(
    blocksize: usize,
    name: String,
    mime_type: String,
    data: Vec<u8>,
) -> *mut Encoder {
    let filepkg: FilePkg = FilePkg::new(name, mime_type, data);
    match to_vec(&filepkg, Endian::Little) {
        Ok(bytes) => init_encode(blocksize, bytes),
        Err(e) => {
            log(&format!("序列化失败: {}", e));
            Box::into_raw(Box::new(Encoder::new(Vec::new(), blocksize, EncoderType::Random)))
        }
    }
}

#[wasm_bindgen]
pub fn next_val(enc: *mut Encoder) -> Vec<u8> {
    let enc: &mut Encoder = unsafe { &mut *enc };
    match enc.next() {
        Some(droplet) => {
            let droplet_pkg: DropletPkg = DropletPkg::from_droplet(droplet);
            let bytes: Vec<u8> = to_vec(&droplet_pkg, Endian::Little).unwrap();
            return bytes;
        }
        None => Vec::new(),
    }
}

#[wasm_bindgen]
pub fn decode_for_file(blocksize: usize, data: Vec<u8>) -> JsValue {
    console_error_panic_hook::set_once();
    
    let decoded_data: Vec<u8> = decode(blocksize, data);
    if decoded_data.is_empty() {
        return JsValue::null();
    }

    match from_vec::<FilePkg>(decoded_data, Endian::Little) {
        Ok(filepkg) => {
            log(&format!(
                "文件信息 - 名称: {}, 类型: {}, 大小: {}字节",
                filepkg.name, filepkg.mime_type, filepkg.data.len()
            ));
            serde_wasm_bindgen::to_value(&filepkg).unwrap_or(JsValue::null())
        },
        Err(e) => {
            log(&format!("文件解码失败: {}", e));
            JsValue::null()
        }
    }
}

#[wasm_bindgen]
pub fn decode(blocksize: usize, data: Vec<u8>) -> Vec<u8> {
    // 反序列化数据包
    let droplet_pkg: DropletPkg = match from_vec::<DropletPkg>(data, Endian::Little) {
        Ok(pkg) => pkg,
        Err(e) => {
            log(&format!("反序列化失败: {}", e));
            return Vec::new();
        }
    };

    // 转换为Droplet
    let drop: Droplet = DropletPkg::to_droplet(droplet_pkg);

    unsafe {
        // 初始化或获取Decoder
        DECODER.get_or_insert_with(|| {
            log(&format!("初始化Decoder: {}", drop.total));
            Decoder::new(drop.total, blocksize)
        });

        // 处理数据包
        match DECODER.as_mut().unwrap().catch(drop) {
            Missing(_) => Vec::new(),
            Finished(result, _) => result,
        }
    }
}
